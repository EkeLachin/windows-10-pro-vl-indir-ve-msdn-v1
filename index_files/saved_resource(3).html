<!DOCTYPE html>
<!-- saved from url=(0075)https://www.fullprogramlarindir.net/windows-10-pro-vl-indir-ve-msdn-v1.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    
    
    <script async="" defer="" src="./launchpad.bundle.js.indir"></script><script type="text/javascript" src="./pwt.js.indir"></script>
<script>
    function isInViewport(el, container) {
        if (!el || !container) {
            return
        }
        const rect = el.getBoundingClientRect();
        return (
            rect.top >= 0 &&
            rect.left >= 0 &&
            rect.top + (rect.height / 2) <= (container.innerHeight || container.document.documentElement.clientHeight) &&
            rect.left + (rect.width / 2) <= (container.innerWidth || container.document.documentElement.clientWidth)

        );
    }

    (function enrich_zeta_global_bids() {
        var pbjs = window.pbjs = window.pbjs || {};
        pbjs.que = pbjs.que || [];

        pbjs.que.push(() => {
            pbjs.onEvent('beforeRequestBids', (adunits) => {
                for (var i in adunits){
                    var bids = adunits[i].bids;
                    for (var j in bids) {
                        if (bids[j].bidder === 'zeta_global_ssp') {
                            bids[j].params = bids[j].params || {tags: {}}
                            bids[j].params.tags['eids'] = owpbjs.getUserIdsAsEids();

                            var in_viewport = isInViewport(window.frameElement, window.parent);
                            if (in_viewport !== undefined) {
                                bids[j].params.tags['inview'] = in_viewport;
                            }
                            break
                        }
                    }
                }
            })
        })
    })()
</script>


    <script src="./launchpad-liveramp.js.indir"></script>

    <script async="" src="./gpt.js.indir"></script>
    <script async="" src="./prebid.7.26.0.js.indir"></script>
    
    

<meta http-equiv="origin-trial" content="Az6AfRvI8mo7yiW5fLfj04W21t0ig6aMsGYpIqMTaX60H+b0DkO1uDr+7BrzMcimWzv/X7SXR8jI+uvbV0IJlwYAAACFeyJvcmlnaW4iOiJodHRwczovL2RvdWJsZWNsaWNrLm5ldDo0NDMiLCJmZWF0dXJlIjoiUHJpdmFjeVNhbmRib3hBZHNBUElzIiwiZXhwaXJ5IjoxNjgwNjUyNzk5LCJpc1N1YmRvbWFpbiI6dHJ1ZSwiaXNUaGlyZFBhcnR5Ijp0cnVlfQ=="><meta http-equiv="origin-trial" content="A+USTya+tNvDPaxUgJooz+LaVk5hPoAxpLvSxjogX4Mk8awCTQ9iop6zJ9d5ldgU7WmHqBlnQB41LHHRFxoaBwoAAACLeyJvcmlnaW4iOiJodHRwczovL2dvb2dsZXN5bmRpY2F0aW9uLmNvbTo0NDMiLCJmZWF0dXJlIjoiUHJpdmFjeVNhbmRib3hBZHNBUElzIiwiZXhwaXJ5IjoxNjgwNjUyNzk5LCJpc1N1YmRvbWFpbiI6dHJ1ZSwiaXNUaGlyZFBhcnR5Ijp0cnVlfQ=="><meta http-equiv="origin-trial" content="A7FovoGr67TUBYbnY+Z0IKoJbbmRmB8fCyirUGHavNDtD91CiGyHHSA2hDG9r9T3NjUKFi6egL3RbgTwhhcVDwUAAACLeyJvcmlnaW4iOiJodHRwczovL2dvb2dsZXRhZ3NlcnZpY2VzLmNvbTo0NDMiLCJmZWF0dXJlIjoiUHJpdmFjeVNhbmRib3hBZHNBUElzIiwiZXhwaXJ5IjoxNjgwNjUyNzk5LCJpc1N1YmRvbWFpbiI6dHJ1ZSwiaXNUaGlyZFBhcnR5Ijp0cnVlfQ=="><script src="./pubads_impl_2022120501.js.indir" async=""></script></head>
<body class="">
    
    
    <div id="container-bottom">
        
        <p class="text-subheading icon__block">Sponsored</p>
        
        
    

    <style>
    /* Reset.less
* Props to Eric Meyer (meyerweb.com) for his CSS reset file. We're using an adapted version here   that cuts out some of the reset HTML elements we will never need here (i.e., dfn, samp, etc).
* ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- */
html,
body {
margin: 0;
padding: 0;
}
h1,
h2,
h3,
h4,
h5,
h6,
p,
blockquote,
pre,
a,
abbr,
acronym,
address,
cite,
code,
del,
dfn,
em,
img,
q,
s,
samp,
small,
strike,
strong,
sub,
sup,
tt,
var,
dd,
dl,
dt,
li,
ol,
ul,
fieldset,
form,
label,
legend,
button,
table,
caption,
tbody,
tfoot,
thead,
tr,
th,
td {
margin: 0;
padding: 0;
border: 0;
font-weight: normal;
font-style: normal;
font-size: 100%;
line-height: 1;
font-family: inherit;
}
table {
border-collapse: collapse;
border-spacing: 0;
}
ol,
ul {
list-style: none;
}
q:before,
q:after,
blockquote:before,
blockquote:after {
content: "";
}
html {
overflow-y: scroll;
font-size: 100%;
-webkit-text-size-adjust: 100%;
    -ms-text-size-adjust: 100%;
        text-size-adjust: 100%;
}
a:focus {
outline: thin dotted;
}
a:hover,
a:active {
outline: 0;
}
article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
nav,
section {
display: block;
}
audio,
canvas,
video {
display: inline-block;
*display: inline;
*zoom: 1;
}
audio:not([controls]) {
display: none;
}
sub,
sup {
font-size: 75%;
line-height: 0;
position: relative;
vertical-align: baseline;
}
sup {
top: -0.5em;
}
sub {
bottom: -0.25em;
}
img {
border: 0;
-ms-interpolation-mode: bicubic;
}
button,
input,
select,
textarea {
font-size: 100%;
margin: 0;
vertical-align: baseline;
*vertical-align: middle;
}
button,
input {
line-height: normal;
*overflow: visible;
}
button::-moz-focus-inner,
input::-moz-focus-inner {
border: 0;
padding: 0;
}
button,
input[type="button"],
input[type="reset"],
input[type="submit"] {
cursor: pointer;
-webkit-appearance: button;
}
input[type="search"] {
-webkit-appearance: textfield;
box-sizing: content-box;
}
input[type="search"]::-webkit-search-decoration {
-webkit-appearance: none;
}
textarea {
overflow: auto;
vertical-align: top;
}
.spinner {
display: inline-block;
margin-right: 5px;
position: relative;
top: 2px;
z-index: 500;
border: 3px solid transparent;
border-color: transparent #c2c9d4 transparent #c2c9d4;
animation: rotate-loading 1.2s linear 0s infinite normal;
transform-origin: 50% 50%;
margin: auto;
width: 25px;
height: 25px;
border-radius: 28px;
}
.spinner.-xs {
width: 11px;
height: 11px;
border-radius: 12px;
border-width: 1px;
}
.spinner.-sm {
width: 16px;
height: 16px;
border-radius: 10px;
border-width: 2px;
}
@keyframes rotate-loading {
0% {
    transform: rotate(0deg);
}
100% {
    transform: rotate(360deg);
}
}
*,
*:before,
*:after {
-webkit-font-smoothing: antialiased;
-moz-osx-font-smoothing: grayscale;
}
.truncate-line {
text-overflow: ellipsis;
word-wrap: break-word;
white-space: nowrap;
overflow: hidden;
min-width: 1px;
}
body {
padding: 0;
margin: 10px 0 0;
font-family: "Helvetica Neue", arial, sans-serif;
}
.serif {
font-family: Georgia, Times, serif;
}
.iab-ad__wrapper {
width: 100%;
max-height: 1090px;
overflow: hidden;
margin-top: 10px;
}
.text-subheading {
font-family: "Helvetica Neue", arial, sans-serif;
font-size: 12px;
font-weight: 700;
color: #7f929c;
}
.dark-theme .text-subheading {
color: #eaedee;
color: rgba(255, 255, 255, 0.85);
}
a {
text-decoration: none;
}
.dark-theme {
background-color: transparent;
color: #fff;
}
.hidden {
display: none !important;
}
.ad-dr {
position: relative;
}
.ad-dr__title {
margin-top: 5px;
}
.ad-dr__message {
padding-right: 5px;
}
.clearfix {
*zoom: 1;
}
.clearfix:before,
.clearfix:after {
display: table;
content: "";
line-height: 0;
}
.clearfix:after {
clear: both;
}
.hide-text {
font: 0/0 a;
color: transparent;
text-shadow: none;
background-color: transparent;
border: 0;
}
/*
    Reusable positioning
*/
.icon__block {
margin-bottom: 10px;
}
.icon__block .icon {
margin-right: 2px;
}
.generic-ad__block {
position: relative;
}
.generic-ad__wrapper {
overflow: hidden;
transition: height 500ms;
}
.align--center {
display: -ms-flexbox;
display: flex;
-ms-flex-align: center;
    align-items: center;
-ms-flex-pack: center;
    justify-content: center;
text-align: center;
}
.ads-position {
margin: 0 2px;
flex: auto;
}
[id^="container-"] {
display: flex;
flex-direction: column;
align-items: flex-start;
width: fit-content;
max-width: 700px;
margin: auto;
}
#container-profile_navbar, #container-explore {
    max-width: 970px;
}

    </style>
    <div id="ad-container-bottom" data-role="ad-container" class="align--center">
        <script>
            
            
                
(function() {
    // start here at our window
    let frame = window;
  
    // if we locate the CMP iframe we will reference it with this
    let cmpFrame;
  
    // map of calls
    const cmpCallbacks = {};
  
    while(frame) {
  
      try {
  
        /**
         * throws a reference error if no frames exist
         */
  
        if (frame.frames['__tcfapiLocator']) {
  
          cmpFrame = frame;
          break;
  
        }
  
      } catch(ignore) {}
  
      if(frame === window.top) {
  
        break;
  
      }
  
      frame = frame.parent;
  
    }
  
   /**
    * Set up a __tcfapi proxy method to do the postMessage and map the callback.
    * From the caller's perspective, this function behaves identically to the
    * CMP API's __tcfapi call
    */
  
    window.__tcfapi = function(cmd, version, callback, arg) {
  
      if (!cmpFrame) {
  
        callback({msg: 'CMP not found'}, false);
  
      } else {
  
        const callId = Math.random() + '';
        const msg = {
          __tcfapiCall: {
            command: cmd,
            parameter: arg,
            version: version,
            callId: callId,
          },
        };
  
        /**
         * map the callback for lookup on response
         */
  
        cmpCallbacks[callId] = callback;
        cmpFrame.postMessage(msg, '*');
  
      }
  
    };
  
    function postMessageHandler(event) {
  
    /**
      * when we get the return message, call the mapped callback
      */
  
      let json = {};
  
      try {
  
        /**
          * if this isn't valid JSON then this will throw an error
          */
  
        json = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;
  
      } catch (ignore) {}
  
      const payload = json.__tcfapiReturn;
  
      if (payload) {
  
        /**
          * messages we care about will have a payload
          */
  
        if (typeof cmpCallbacks[payload.callId] === 'function') {
  
          /**
           * call the mapped callback and then remove the reference
           */
  
          cmpCallbacks[payload.callId](payload.returnValue, payload.success);
          cmpCallbacks[payload.callId] = null;
  
        }
  
      }
  
    }
  
    window.addEventListener('message', postMessageHandler, false);
  
  }());
            
            (() => {
                
function has(obj, key) {
    // The object.hasOwnProperty method fails when the
    // property under consideration is named 'hasOwnProperty'.
    return Object.prototype.hasOwnProperty.call(obj, key);
}



/*
 * Iterates over an object or a collection and calls a callback
 * function with each item as a parameter.
 */
function each(collection, callback) {
    var length = collection.length;
    var forEach = Array.prototype.forEach;

    if (isNaN(length)) {
        // Treat collection as an object
        for (var key in collection) {
            if (has(collection, key))
                callback(collection[key], key, collection);
        }
    } else if (forEach) {
        // Treat collection as an array
        forEach.call(collection, callback);
    } else {
        for (var i = 0; i < length; i++)
            callback(collection[i], i, collection);
    }
}

/**
 * Create an object from the key-value pairs in a query string.
 * Duplicate keys are not supported (only last value will be used).
 *
 * @param {string} [queryString] - The search portion of a url. Must start with a ?.
 *                                 Defaults to window.location.search.
 * @returns {Object<string>} - The mapping of query string keys to values.
 */
function parseQueryString(queryString) {
    if (typeof queryString === 'undefined')
        queryString = window.location.search;

    var params = {};

    each(queryString.substr(1).split('&'), function (item) {
        var pair = item.split('=').map(function (part) {
            return decodeURIComponent(part.replace(/\+/g, '%20'));
        });
        if (pair[0])
            params[pair[0]] = pair[1];
    });

    return params;
}


/**
* Wrap a function such that it can only be run once. The return value is cached and returned in subsequent calls.
* @param {function} fn - Function to wrap.
* @returns {any} - Return value as returned by the first invocation of fn, regardless of arguments.
*/
function once(fn) {
    var returnValue;
    return function () {
        if (fn) {
            returnValue = fn.apply(this, arguments);
            fn = null;
        }
        return returnValue;
    };
}

if (window.getComputedStyle) {
    getCurrentStyle = function(elem, prop, _camel) {
        try {
            // We need this to both protect for the case where `elem` is not valid,
            // such as it being `document` and for the broken ShadowDOMPolyfill script.
            // See https://git.io/vrPIf for more details.
            return window.document.defaultView.getComputedStyle(elem, null).getPropertyValue(prop);
        } catch (err) {
            return null;
        }
    };
} else {
    // IE < 9, Opera
    getCurrentStyle = function(elem, prop, camel) {
        return elem.currentStyle[prop] || elem.currentStyle[camel];
    }
}

/**
* Get the height of the document.
*
* @returns {number} - The document height
*/
function getDocumentHeight() {
    const container = document.body;
    var height = container.offsetHeight

    var marginTop = parseInt(getCurrentStyle(container, 'margin-top', 'marginTop'), 10);
    if (marginTop)
        height += marginTop;

    var marginBottom = parseInt(getCurrentStyle(container, 'margin-bottom', 'marginBottom'), 10);
    if (marginBottom)
        height += marginBottom;

    return height;
}

/**
* Starts a loop to notice changes to the page height.
*
* @param {function} cb - Function to call with new height values.
* @returns {void}
*/
function onHeightChange(cb) {
    let count = 0;
    let lastHeight = 0;

    const loop = () => {
        const currentHeight = getDocumentHeight();
        if (currentHeight !== lastHeight) {
            lastHeight = currentHeight;
            cb(currentHeight);
        }

        // We'll watch for height changes for a total of ~25.4 seconds,
        // with these intervals:
        // 100ms, 100ms, 200ms, 200ms, 400ms, 400ms, ..., 6400ms
        // The idea behind these intervals is the following:
        // - on fast websites, with small number of widgets, ad provider
        // will be loaded fast and has good chances to be visible right away,
        // so we need to detect resize quickly
        // - on slow websites it doesn't make sense to check for resize every
        // 100ms because well, they're slow and it might take more than 5sec
        // for ad provider to render. Also most likely page will be long and it
        // will take some time for user to scroll down
        /* eslint-disable no-magic-numbers */
        count += 1;
        if (count < 15)
            setTimeout(loop, 100 * Math.pow(2, Math.floor(count / 2)));
        /* eslint-enable no-magic-numbers */
    };

    loop();
}

/**
* Send a message to the host page. Mimics the format
* used by core/utils/frameBus.
*
* @param {string} name - The event name.
* @param {*} data - JSON-serializable data to send.
* @returns {void}
*/
function sendMessageToHost(name, data) {
    data = data || {};
    window.parent.postMessage(JSON.stringify({
        data,
        name,
        scope: 'host',
        sender:  window.name ,
    }), '*');
}


const POST_MESSAGE_TYPES = Object.freeze({
    click: 'click',
    errorProviderNotReady: 'error-provider-not-ready',
    errorNoHeight: 'error-no-height',
    ready: 'ready',
    resize: 'resize',
    redirect: 'redirect',
});

// The minimum height which indicates an ad has loaded.
// Height of Sponsored text and margin is 32 pixels.
const minHeight = 35;

/**
* Generates events for resizing the frame and ad loads.
*
* @param {Object} options - Options
*   {function} readyData - The data to include with the ready event.
* @returns {function} - A callback which should be called when the provider indicates the ad is ready.
*/
function startAdsLoop(readyData) {
    const startTime = new Date().getTime();

    let providerReadied = false;
    let minHeightReached = false;
    // This parameter isn't expected in the ready event so we delete it after capturing it's value.
    const sendReady = readyData.sendReady;
    delete readyData.sendReady;

    const sendReadyOnce = once(() => {
        const extraData = window._OnReadyExtraData;
        if (extraData) {
            extraData.time_to_load = new Date().getTime() - startTime;
            readyData.extraData = JSON.stringify(extraData);
        }

        sendMessageToHost(POST_MESSAGE_TYPES.ready, readyData);
    });
    const detectReadyMismatch = once(() => {
        setTimeout(() => {
            if (!providerReadied)
                sendMessageToHost(POST_MESSAGE_TYPES.errorProviderNotReady, { provider: readyData.provider });

            const heightReached = minHeightReached || getDocumentHeight() >= minHeight;
            if (!heightReached)
                sendMessageToHost(POST_MESSAGE_TYPES.errorNoHeight, { provider: readyData.provider });
        }, 100); // eslint-disable-line no-magic-numbers
    });

    onHeightChange(height => {
        if (height < minHeight)
            return;

        minHeightReached = true;
        if (sendReady) {
            sendReadyOnce();
        }
        detectReadyMismatch();
        sendMessageToHost(POST_MESSAGE_TYPES.resize, { height });
    });

    return once(() => {
        providerReadied = true;
        detectReadyMismatch();
    });
}

function uuidv4() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}

                const onAdLoad = startAdsLoop({
    advertisement_id: 160465,
    forumId: 2613124,
    sendReady: false,
});

const startTime = new Date().getTime();

var googletag = window.googletag = window.googletag || {};
googletag.cmd = googletag.cmd || [];

var pbjs = window.pbjs = window.pbjs || {};
pbjs.que = pbjs.que || [];

googletag.cmd.push(function() {
    googletag.pubads().disableInitialLoad();
});


// The doublewide_threshold is the minimum width required on the page before the double ad experience kicks in.
// Previously we used the width of 2 ads (each 300px wide) + 8px whitespace in between. The plan is to use a slightly
// lower width since many pages are just shy of that threshold. Sites that look bad can be managed by disabling
// doublewide.
const doublewideEnabled = document.body.offsetWidth >= 590;


const tmax = 5000;

// We need to create HTML elements for the ad slots we are going to run.
const container = document.getElementById('ad-container-bottom');
const div1 = document.createElement('div');
const div2 = document.createElement('div');
div1.className = 'ads-position';
div2.className = 'ads-position';
div1.id = 'ad-1';
div2.id = 'ad-2';



container.appendChild(div1);
if (doublewideEnabled)  {
    container.appendChild(div2);
}

pbjs.que.push(function() {
    pbjs.addAdUnits([{
        code: div1.id,
        mediaTypes: {"banner":{"sizes":[[300,250]]}},
        bids: [{"params":{"tags":{"origin":"google","position":"bottom","shortname":"fullprogramlarindir","backfill":false},"tmax":110,"definerId":"42770","user":{"buyeruid":null},"sid":1997295,"device":{"ip":"87.106.157.54","geo":{"country":"ESP"}}},"bidder":"zeta_global_ssp"}],
    }]);

    if (doublewideEnabled) {
        pbjs.addAdUnits([{
            code: div2.id,
            mediaTypes: {"banner":{"sizes":[[300,250]]}},
            bids: [{"params":{"tags":{"origin":"google","position":"bottom","shortname":"fullprogramlarindir","backfill":false},"tmax":110,"definerId":"42770","user":{"buyeruid":null},"sid":1997295,"device":{"ip":"87.106.157.54","geo":{"country":"ESP"}}},"bidder":"zeta_global_ssp"}],
        }]);
    }

    pbjs.setConfig(makeConfig());

    pbjs.setBidderConfig({
        bidders: ["grid"],
        config: {
            localStorageWriteAllowed: true,
        },
    });

    pbjs.bidderSettings = {
        standard: {
            storageAllowed: true,
        }
    };

    pbjs.enableAnalytics([{
        provider: 'atsAnalytics',
        options: {
            pid: '13553'
        }
    }]);

    pbjs.requestBids({
        bidsBackHandler: bidsBackHandler,
        timeout: tmax,
    });
});

const makeConfig = () => {
    return {
        
        useBidCache: true,
        bidCacheFilterFunction:
            (bid) => {
                return bid.bidder === 'openx';
            },
        
        // Video Ad cache store
        cache: {
            url: 'https://prebid.adnxs.com/pbc/v1/cache'
        },
        
        consentManagement: {
            
            gdpr: {
                cmpApi: 'iab',
                timeout: 5000,
                defaultGdprScope: true
            }
            
        },
        
        priceGranularity: 'dense',
        userSync: {"userIds":[{"storage":{"expires":28,"type":"cookie","name":"sharedid"},"name":"sharedId"},{"name":"uid2"},{"storage":{"expires":15,"type":"html5","name":"idl_env","refreshInSeconds":1800},"params":{"pid":"13553"},"name":"identityLink"}],"filterSettings":{"iframe":{"filter":"include","bidders":"*"}}},
        pageUrl: "https://www.fullprogramlarindir.net/windows-10-pro-vl-indir-ve-msdn-v1.html",
        
        schain: {
            validation: 'strict',
            config: {
                ver: '1.0',
                complete: 1,
                nodes: [{
                    'asi': 'disqus.com',
                    'sid': '1997295',
                    'rid': uuidv4(),
                    'hp': 1, // Always 1 for version 1.0
                }],
            },
        },
        
        
    }
}

const skipBackfill = 'skipBackfill=true';
const googleSlot = '/101482493/position/bottom';

const definedSlots = {};
definedSlots[div1.id] = null;
definedSlots[div2.id] = null;

var numAds = doublewideEnabled ? 2 : 1;
var readyExtraData = {};
var slotRenderEndedCounter = 0;
var slotRenderEmptyCounter = 0;
var firstAuction = true;


// We refresh ads (each slot) untill the first no-bid. As such we need to track refresh stats for each slot.
const refreshNeeded = {};
refreshNeeded[div1.id] = true;
refreshNeeded[div2.id] = true;

var displaySizes = [[300, 250]];


googletag.cmd.push(function() {
    definedSlots[div1.id] = googletag.defineSlot(googleSlot, [[300, 250], 'fluid'], div1.id).addService(googletag.pubads());
    if (doublewideEnabled) {
        definedSlots[div2.id] = googletag.defineSlot(googleSlot, [[300, 250], 'fluid'], div2.id).addService(googletag.pubads());
    }
    googletag.pubads().enableSingleRequest();
    googletag.pubads().collapseEmptyDivs();
    googletag.pubads().set('page_url', 'https://www.fullprogramlarindir.net/windows-10-pro-vl-indir-ve-msdn-v1.html');
    googletag.pubads().setTargeting('shortname', 'fullprogramlarindir');
    
    googletag.pubads().setTargeting('experiment:variant', 'network_default:fallthrough');
    
    googletag.pubads().addEventListener('slotRenderEnded', (event) => {
        const domId = event.slot.getSlotId().getDomId();
        // This is run when an auction ends and an ad is rendered (or not rendered if no one won the auction) into the
        // HTML. It runs for every adslot/adunit on the page. In every run we save parameters for the respective auctions
        // and on the last run we also fire the ready event/message along with these parameters.
        if (event.isEmpty) {
            // We use this counter to determine if we need to backfill after the first auction.
            if (firstAuction) {
                slotRenderEmptyCounter++;
            }

            
            refreshNeeded[domId] = false;
            pbjs.removeAdUnit(domId);
            
        } else {
            onAdLoad();

            // First we save all the parameters for this auction.
            let winner;
            // Based on manual testing, when the event has a lineItemId (or creativeId for that matter) it means that a
            // prebid bidder won the auction. It is set to null when google wins.
            const prebidWinners = event.lineItemId && pbjs.getAllWinningBids();
            const prebidWinner = prebidWinners && prebidWinners.filter(bid => bid.adUnitCode === domId)[0];
            if (prebidWinner) {
                winner = prebidWinner.bidder;
            } else {
                winner = 'dfp';
            }

            var bids = {};
            var pbjsAdUnitBids = pbjs.getBidResponses()[domId];
            // Handle doublewide logging suffix.
            var suffix = '';
            if (domId != div1.id) {
                suffix = '1';
            }
            if (pbjsAdUnitBids) {
                pbjsAdUnitBids.bids.forEach((bid) => {
                    bids[bid.bidder] = {
                        code: bid.bidder,
                        cpm: bid.cpm,
                        cpm_auto: bid.pbAg,
                        // we refer to banner ads as display ads
                        media_type: (bid.mediaType === 'banner') ? 'display' : bid.mediaType,
                        time_to_respond: bid.timeToRespond,
                        status: bid.statusMessage,
                    };
                });
                readyExtraData['bids' + suffix] = bids;
            }
            readyExtraData['winner' + suffix] = winner;

            // We also need to delete the taboola unit if we want to render this ad
            const taboolaElement = document.getElementById('taboola');
            if (taboolaElement) {
                taboolaElement.remove();
            }
        }

        // When all ads have been loaded we can fire the ready event.
        slotRenderEndedCounter++;
        if (slotRenderEndedCounter === numAds) {
            if (firstAuction) {
                firstAuction = false;
                // After sending messages for all the slots, if all the slots are rendered
                // and all were empty backfill with taboola
                if (slotRenderEmptyCounter === numAds && !document.cookie.includes(skipBackfill) && !window.isAniviewEnabled) {
                    
                    sendMessageToHost('resize', {height: 0});
                    
                }
            }

            // Here we fire the ready even that tracks auction winners.
            // TODO: Support multiple fires of this event in sendMessageToHost.
            readyExtraData.time_to_load = new Date().getTime() - startTime;
            sendMessageToHost(POST_MESSAGE_TYPES.ready, {
                forumId: 2613124,
                advertisement_id: 160465,
                provider: 'google',
                extraData: JSON.stringify(readyExtraData),
            });

            
            if (doublewideEnabled) {
                if (refreshNeeded[div1.id] || refreshNeeded[div2.id]) {
                    numAds = [refreshNeeded[div1.id], refreshNeeded[div2.id]].filter(Boolean).length;
                    slotRenderEndedCounter = 0;
                    readyExtraData = {};
                    setTimeout(refreshAds, 30000);
                }
            } else {
                if (refreshNeeded[div1.id]) {
                    slotRenderEndedCounter = 0;
                    readyExtraData = {};
                    setTimeout(refreshAds, 30000);
                }
            }

            
        }
    });
    googletag.enableServices();
    // Google docs suggest having display called after enableServices and targeting.
    googletag.display(div1.id);
    if (doublewideEnabled) {
        googletag.display(div2.id);
    }
});

function bidsBackHandler() {
    googletag.cmd.push(function() {
        pbjs.setTargetingForGPTAsync && pbjs.setTargetingForGPTAsync();
        
        googletag.pubads().refresh();
        
    });
}

window.onDFPNoFill = function(doc) {
    const bids = pbjs.getHighestCpmBids();
    bids.forEach(bid => {
        pbjs.renderAd(doc, bid.adId);
    });
};

function refreshBidsBackHandler(bids) {
    if (bids && Object.keys(bids).length > 0) {
        // We only want to refresh the google slots for which we got prebid bids back.
        const slots = [];
        for (const [code, values] of Object.entries(bids)) {
            slots.push(definedSlots[code]);
        }
        googletag.cmd.push(function() {
            pbjs.setTargetingForGPTAsync && pbjs.setTargetingForGPTAsync();
            
            googletag.pubads().refresh(slots);
            
        });
    }
}

function refreshAds() {
    pbjs.setConfig(makeConfig());
    pbjs.requestBids({
        bidsBackHandler: refreshBidsBackHandler,
        timeout: tmax,
    });
}

            })();
        </script><div class="ads-position" id="ad-1"></div><div class="ads-position" id="ad-2"></div>
    </div>

    </div>


    <img src="./711970.gif" style="display: none" alt="">



<iframe name="__launchpadLocator" style="display: none;" src="./saved_resource(8).html"></iframe></body></html>